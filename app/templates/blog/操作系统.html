{% extends "base.html" %}
{% block header %}
{% endblock %}
{% block content %}
<h1>操作系统</h1>

<h1>os</h1>

<h2>文件描述符</h2>

<p>指向内核为每一个进程维护的该进程打开文件记录表，当程序打开一个现有文件或者创建新文件时，内核向进程返回文件描述符</p>

<h3>进程和线程</h3>

<p>进程</p>

<ul>
<li>进程是一块包含了某些资源的内存区域，包含的一个或者多个执行单元称为线程</li>
<li>进程有一个私有的虚拟地址空间，该空间仅能被它包含的线程使用</li>
</ul>

<p>线程</p>

<ul>
<li>线程有他的独特的程序计数器，栈，寄存器</li>
<li>堆内存和全局变量 线程是共享的</li>
<li>一个线程死掉就相当于这个线程的进程死掉，所以多进程比多线程好</li>
<li>线程不能独立执行</li>
</ul>

<h2>thread分为两类</h2>

<p>posix线程以及windows 线程，unix系统都是posix 线程即pthread. windows 线程即为微软开发的线程。</p>

<h4>thread 线程的状态</h4>

<p>新建状态
就绪状态
运行状态
阻塞状态
死亡状态</p>

<p>yield（）暂时交出 cpu 控制权，从 running 状态转为 runnalbe 状态，但是仍有 可能被调度，sleep（）线程指定休眠一段时间，wait（）在其他线程调用此对 象的 notify（）或 notifyAll（）方法时才能继续执行 线程中 sleep()方法和 yeild()方法的主要区别:</p>

<p>多核cpu可以每个核来运行一个线程，同时运行多个线程</p>

<p>1.计算机某一时刻最多有一个进程
一个进程可以包含多个线程
2.同一个进程中的线程共享内存空间</p>

<p>3.一个线程使用内存时， 其他线程不能进去抢占   信号量，
互斥锁， 互斥锁是信号量的低级版本 只能0，1</p>

<h3>信号量</h3>

<p>用于互斥时，信号量的值应该初始化为1，任何时候只能由单个进程或者线程拥有</p>

<p>用P V来操作，P代表值减小，V代表值增加</p>

<p>当信号量大于0时，代表资源可以使用， 进程调用资源，信号量减少
当信号量为0时，必须等待其他进程释放信号量</p>

<h4>操作系统竞态</h4>

<p>并发的执行单元对共享资源的访问导致竞态</p>

<p>两个进程试图向同一个设备的相同位置写入数据</p>

<h5>解决办法 加锁，或者确保同一时间只有一个进程在执行操作</h5>

<h3>进程的上下文切换</h3>

<p>操作系统保存正在运行的进程状态，恢复进程的状态</p>

<p>保存的内容: 寄存器的值和内存分配的情况</p>

<p>4.进程是会死锁的</p>

<p>使用fork函数得到的子进程从父进程的继承了整个进程的地址空间，包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。</p>

<p>子进程与父进程的区别在于：</p>

<p>1、父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）</p>

<p>2、各自的进程ID和父进程ID不同</p>

<p>3、子进程的未决告警被清除；</p>

<p>4、子进程的未决信号集设置为空集。 -mickole博客</p>

<h4>死锁</h4>

<p>两个执行单元互相持有对方的资源，同时互相等待对方的资源而产生的阻塞</p>

<p>解决死锁的办法:</p>

<ul>
<li>同一时刻一个线程只能访问一个资源</li>
<li>为访问资源设置一个最大的等待时间，.NET的同步机制</li>
</ul>

<p>有哪些方法处理队列中的线程，</p>

<p>关于死锁的问题。哪些情况下会产生死锁</p>

<p>当两个执行单元互相持有对方的资源，同时等待对方的资源产生的阻塞</p>

<p>如何让两个进程产生死锁</p>

<p>并发</p>

<h2>进程调度算法</h2>

<p>FCFS  first come first server</p>

<h5>高优先权优先调度算法   按照进程的优先度来调度</h5>

<p>RR Round robin(知更鸟) 轮询法  每个进程都可以得到一个最短的cpu使用时间，维护一个进程队列</p>

<p>SJF 最短作业优先算法</p>

<p>多级队列:  多个调度算法一起使用</p>

<p>通过画甘特图来计算时间</p>

<h3>线程调度算法</h3>

<h2>生产者消费者模型</h2>

<p>实现并发</p>

<p>用一个缓冲队列来记录:</p>

<p>提前生产好若干个资源，然后调用出资源，生产后进入资源</p>

<h4>进程之间的通讯</h4>

<h6>通讯目的:</h6>

<p>数据传输：一个进程将他的数据发送给另一个进程</p>

<p>共享数据</p>

<p>资源共享</p>

<p>进程控制</p>

<p>三种</p>

<p>普通管道</p>

<p>流管道</p>

<p>命名管道</p>

<p>系统IPC</p>

<p>信号量：信号量是一个计数器，可以控制多个进程对资源的访问</p>

<p>消息队列: 消息队列是由消息的链表</p>

<p>socket</p>

<p>共享内存:共享内存是映射一段能被其他进程访问的n内存，由一个进程创建，多个进程共享</p>

<h4>操作系统是如何实现异步的。python 有哪些异步框架</h4>

<h1>内存和存储</h1>

<h2>虚拟内存</h2>

<p>防止物理内存不够用，将硬盘的一部分作为虚拟</p>

<p>将程序分为若干个 较小的段和页，用映像表来表示是否装入了内存。</p>

<h3>段式管理</h3>

<p>优点</p>

<ul>
<li>模块化性能好</li>
<li>便于程序和数据共享</li>
<li>程序的动态链接和调度比较容易</li>
<li>便于实现信息保护</li>
</ul>

<p>缺点:</p>

<ul>
<li>地址变换的时间较长，需要两次加法运算</li>
<li>主储存器的利用率比较低</li>
<li>对辅存的管理比较困难</li>
<li>会造成内存碎片，造成浪费</li>
</ul>

<h3>分配算法</h3>

<p>首先分配:找到第一个可用空间，然后分配
最佳分配:先扫描全局可用区域表，然后找一个可用区进行分配</p>

<h3>页式管理</h3>

<p>将主存空间和程序空间分为固定大小的页，按照页顺序编号</p>

<p>虚拟地址中为虚页，主存地址中为实页</p>

<p>每个用户有一个在cpu中的基址寄存器，可以根据用户号在 找到与用户程序相对应的基址寄存器</p>

<p>从基址寄存器中读取到页表的起始地址，访问页表地址，将得到的主存页号和页内偏移加起来的到主存实地址</p>

<h1>linux常用知识</h1>

<p>linux文件权限:
第一段:文件类型
第二段:文件所有者的权限
第三段:文件在组成员的，读写执行权限
第四段:其他用户的读写执行权限</p>

<p>du-sh  查看文件夹的大小
cd
ls
grep 与管道命令进行 结合   进行内容的筛选
find 命令
cp copy
mv 命令
rm -rf 递归删除
ps 命令
kill
file  filename  找到文件名
tar 打包压缩
cat 查看文件内容
chmod 改变文件权限
vim
gcc
time</p>

{% endblock %}
