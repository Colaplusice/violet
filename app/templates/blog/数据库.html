{% extends "base.html" %}
{% block header %}
{% endblock %}
{% block content %}
    <h1>数据库</h1>

    <h2>数据库</h2>

    <h4>ACID</h4>

    <h6>a:atomicity原子性 一个事务包含多个操作，这些操作要么全部执行，要么不执行,在某个操作失败后，回滚到事务之前的操作</h6>

    <h6>c:一致性，系统从一个一致的状态，转移到另一个一致的状态。修改和添加的任何数据，必须遵循每个表的规则，外键，级联删除，触发器。当某个条件不满足时，事务应该停止操作。必须满足所有的规则</h6>

    <h6>I:Isolation:隔离性，当一个事务的操作并行执行时，结果应该和他串行的方法保持一致</h6>

    <h6>S:durablity: 持久性，事务提交后，对系统的影响是持久的，数据必须永不丢失。</h6>

    <h3>主键</h3>

    <p><strong>1、数据库的每张表只能有一个主键，不可能有多个主键。</strong></p>

    <p><strong>2、所谓的一张表多个主键，我们称之为联合主键。</strong></p>

    <p><code>
        **注：联合主键：就是用多个字段一起作为一张表的主键。**
    </code></p>

    <p><strong>3、主键的主键的作用是保证数据的唯一性和完整性，同时通过主键检索表能够增加检索速度。</strong></p>

    <p>主键和unique的区别</p>

    <p>unique可空</p>

    <p>一个table 只能有一个主键 但是可以有多个unique</p>

    <p>建立unique的同时建立索引</p>

    <h3>外键的优缺点</h3>

    <p>优点，保证数据的一致性，完整性，更可靠，外键要添加索引</p>

    <ol>
        <li>增强er图的可读性</li>
        <li>使设计更全面</li>
        <li>级联性能未必会低</li>
        <li>导致冗余 最底层的表可能会重复几遍数据</li>
    </ol>

    <p>缺点:</p>

    <p>性能差 对一个表的增加和修改，需要去查找和修改其他的表，完全可以通过逻辑来实现</p>

    <p>维护麻烦 手动修改不太容易</p>

    <p>定死了先后的生成关系，先生成明细，再生成主表</p>

    <h2>数据类型</h2>

    <p>char是占用确定的空间，varchar只会占用实际字符的空间+1</p>

    <p>char 的上限是255，varchar的上限是65535个字节 text上限是65535</p>

    <h2>隔离级别</h2>

    <p>未提交读:允许脏读，可能读取到其他会话中未提交事务修改的数据。</p>

    <p>提交读:只能读取到已经提交的数据，多数数据库的默认级别</p>

    <p>可重复读:同一个事务内的查询都是事务开始时刻一致的，InnDB默认级别，消除了不可重复读，还存在幻象读</p>

    <p>串行读：读写是阻塞的。每次读都要获得表级共享锁</p>

    <h3>范式</h3>

    <p>1NF</p>

    <p>无重复的列，数据库每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子项，</p>

    <p>如果属性中的某个属性有多个值时，必须拆分为不同的属性。</p>

    <p>2NF</p>

    <p>第二范式是在第一范式的基础上建立起来的，第二范式首先满足第一范式</p>

    <p>主键的唯一性，是第二范式的约束，只能依赖于其中的一个主键</p>

    <p>3NF</p>

    <p>属性不能依赖于主属性，第三范式是在2NF的基础上建立起来的</p>

    <p>特点:属性不依赖于其他非主键属性</p>

    <p>BCNF:</p>

    <p>每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。</p>

    <h3>触发器</h3>

    <p>对某个操作设定的操作，当完成某个操作时，自动执行触发器操作</p>

    <p>优点:数据一致性约束</p>

    <p>类似于</p>

    <h1>索引</h1>

    <h4>如何建立索引</h4>

    <p>索引是一种数据结构</p>

    <p>目的:减少搜索的范围来提高搜索技术</p>

    <h4>索引种类</h4>

    <p>b-树，时间复杂度低，插入，删除，查找在对数时间完成，是有序的</p>

    <p>b+树，</p>

    <h4>为什么不用红黑树作为数据库的索引</h4>

    <p>红黑树是一种二叉查找树</p>

    <p>操作系统读取磁盘的单位是扇区，文件的基本单位为簇</p>

    <p>磁盘读写有一个最少内容限制，必须读取一个簇</p>

    <p>b+树的多少个分支按照磁盘有多少个节点来设计的。</p>

    <h4>hash索引</h4>

    <p>优点:效率快</p>

    <p>缺点:</p>

    <ol>
        <li>hash索引在遇到大量键值相等的情况下，效率不一定高</li>
        <li>hash索引需要对table进行扫描</li>
        <li>hash索引无法避免对数据的排序操作</li>
        <li>仅仅支持&lt;=&gt;以及in操作</li>
    </ol>

    <p>在一个字段建立索引，可以很快的查找，只储存这个字段</p>

    <p>缺点: 索引也要占空间，表内数据越多，占据的空间越大</p>

    <p>2.性能损失，索引会提高查询速度 在表中添加或者删除数据，索引也要更新一遍</p>

    <p>索引越简单越好，在磁盘和内存上需要空间</p>

    <h3>mysql索引的顺序</h3>

    <h2>乐观锁 悲观锁</h2>

    <p>并发控制:</p>

    <p>乐观锁: 在处理并发时假设多用户的事务在处理时不受到彼此影响，各事务能在不产生锁的情况下处理各自影响的那部分数据。 等到事务处理完成在提交时进行数据检查，看有没有其他事务修改了该数据。如果有的话，正在提交的事务会回滚。
        在并发量不是很大的情况下适用。</p>

    <p>三个步骤</p>

    <ol>
        <li><p>读取:事务将数据读入缓存，系统会分配一个时间戳</p></li>
        <li><p>事务执行完毕后，进行提交，这时候会同步验证所有的事务。如果发生冲突，回滚。</p></li>
        <li><p>通过校验阶段，将更新的数据写入数据库</p></li>
    </ol>

    <p>悲观锁:</p>

    <p>阻止一个事务以影响其他用户的方式来修改数据，如果一个事务执行的操作读取某行数据 应用了锁，只有在他读取完成后其他事务才能调用这个数据。</p>

    <p>缺点:会产生额外的开销，有可能增加死锁。</p>

    <h1>sql</h1>

    <h4>修改</h4>

    <p><code>
        UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
    </code></p>

    <p>update mysql.user set Host= '%' where User='root';</p>

    <h4>删除</h4>

    <p>delete from test1_student where age=20;</p>

    <h4>查询表的行数</h4>

    <p>select COUNT(*) from <code>ansj_sentence</code></p>

    <h4>插入</h4>

    <p>insert into test1<em>teacher</em>course values (100101,300001)</p>

    <h4>新建</h4>

    <p>Create table test1_student(sid char(12),name varchar(10),sex char (2),age int,birthday date,dname
        varchar(30),class varchar(10));</p>

    <h4>table迁移</h4>

    <p><code>
        1.方法一： 登录导出到的数据库，执行CREATE table bio_literature SELECT * from shixun.`bio_literature`
    </code></p>

    <h3>安全</h3>

    <p>sql注入</p>

    <p>将sql命令插入到web表单中，欺骗服务器执行特定的sql命令</p>

    <p>用户输入的内容动态构建sql命令</p>

    <p>预防办法:</p>

    <ul>
        <li>对用户输入的数据进行处理</li>
        <li>限制表单或者字符串输入的长度</li>
    </ul>

    <h2>零碎知识点</h2>

    <p>数据库的概念模型独立于 现实世界和DBMS</p>

    <p>mysql 配置文件
        恢复模式启动mysql
        innodb<em>force</em>recovery = 1</p>

    <h2>完整性约束</h2>

    <p>实体完整性约束： 每个数据都是唯一的
        域完整性： 数据具有正确的格式和数据范围，数据类型
        参照完整性约束: 增加删除数据时，保证其他表的数据也一致
        用户定义完整性约束: 用户自定义的完整性</p>

{% endblock %}
